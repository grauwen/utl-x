/**
 * Mode Selector Widget
 *
 * UI component for switching between Design-Time and Runtime modes.
 * Displays as a toolbar above the main panels.
 */

import * as React from 'react';
import { injectable, inject, postConstruct } from 'inversify';
import { ReactWidget } from '@theia/core/lib/browser/widgets/react-widget';
import { MessageService } from '@theia/core';
import {
    UTLXService, UTLX_SERVICE_SYMBOL,
    UTLXMode,
    ModeConfiguration,
    MODE_SELECTOR_ID
} from '../../common/protocol';

export interface ModeSelectorState {
    currentMode: UTLXMode;
    autoInferSchema: boolean;
    enableTypeChecking: boolean;
}

@injectable()
export class ModeSelectorWidget extends ReactWidget {
    static readonly ID = MODE_SELECTOR_ID;
    static readonly LABEL = 'Mode Selector';

    @inject(UTLX_SERVICE_SYMBOL)
    protected readonly utlxService!: UTLXService;

    @inject(MessageService)
    protected readonly messageService!: MessageService;

    private state: ModeSelectorState = {
        currentMode: UTLXMode.RUNTIME,
        autoInferSchema: false,
        enableTypeChecking: true
    };

    private modeChangeCallbacks: ((mode: UTLXMode) => void)[] = [];

    constructor() {
        super();
        this.id = ModeSelectorWidget.ID;
        this.title.label = ModeSelectorWidget.LABEL;
        this.title.closable = false;
        this.addClass('utlx-mode-selector');
    }

    @postConstruct()
    protected async init(): Promise<void> {
        this.update();

        // Load current mode from service
        try {
            const config = await this.utlxService.getMode();
            this.setState({
                currentMode: config.mode,
                autoInferSchema: config.autoInferSchema || false,
                enableTypeChecking: config.enableTypeChecking !== false
            });
        } catch (error) {
            console.error('Failed to load mode configuration:', error);
        }
    }

    protected onActivateRequest(msg: Message): void {
        super.onActivateRequest(msg);
        this.update();
    }

    protected render(): React.ReactNode {
        const { currentMode, autoInferSchema, enableTypeChecking } = this.state;

        return (
            <div className='utlx-mode-selector-container'>
                <div className='utlx-mode-toggle'>
                    <span className='utlx-mode-label'>Mode:</span>
                    <div className='utlx-mode-buttons'>
                        <button
                            className={`utlx-mode-button ${currentMode === UTLXMode.DESIGN_TIME ? 'active' : ''}`}
                            onClick={() => this.handleModeChange(UTLXMode.DESIGN_TIME)}
                            title='Design-Time: Schema-based type checking'
                        >
                            üé® Design-Time
                        </button>
                        <button
                            className={`utlx-mode-button ${currentMode === UTLXMode.RUNTIME ? 'active' : ''}`}
                            onClick={() => this.handleModeChange(UTLXMode.RUNTIME)}
                            title='Runtime: Execute transformations with data'
                        >
                            ‚ñ∂Ô∏è Runtime
                        </button>
                    </div>
                </div>

                <div className='utlx-mode-description'>
                    {this.getModeDescription(currentMode)}
                </div>

                {currentMode === UTLXMode.DESIGN_TIME && (
                    <div className='utlx-mode-options'>
                        <label className='utlx-checkbox-label'>
                            <input
                                type='checkbox'
                                checked={autoInferSchema}
                                onChange={(e) => this.handleAutoInferSchemaChange((e.target as HTMLInputElement).checked)}
                            />
                            Auto-infer schema on change
                        </label>
                        <label className='utlx-checkbox-label'>
                            <input
                                type='checkbox'
                                checked={enableTypeChecking}
                                onChange={(e) => this.handleTypeCheckingChange((e.target as HTMLInputElement).checked)}
                            />
                            Enable type checking
                        </label>
                    </div>
                )}

                <div className='utlx-mode-info'>
                    {this.getModeInfo(currentMode)}
                </div>
            </div>
        );
    }

    private getModeDescription(mode: UTLXMode): string {
        switch (mode) {
            case UTLXMode.DESIGN_TIME:
                return 'üìê Use schemas to validate transformation logic without data';
            case UTLXMode.RUNTIME:
                return 'üöÄ Execute transformations with actual input data';
        }
    }

    private getModeInfo(mode: UTLXMode): React.ReactNode {
        switch (mode) {
            case UTLXMode.DESIGN_TIME:
                return (
                    <div className='utlx-mode-info-box'>
                        <strong>Design-Time Mode:</strong>
                        <ul>
                            <li>‚úì Load input schema (XSD, JSON Schema)</li>
                            <li>‚úì Type-check transformation paths</li>
                            <li>‚úì Infer output schema</li>
                            <li>‚úì Catch errors before deployment</li>
                            <li>‚úó No data execution</li>
                        </ul>
                    </div>
                );
            case UTLXMode.RUNTIME:
                return (
                    <div className='utlx-mode-info-box'>
                        <strong>Runtime Mode:</strong>
                        <ul>
                            <li>‚úì Load input data (XML, JSON, CSV, YAML)</li>
                            <li>‚úì Execute transformation</li>
                            <li>‚úì View output data</li>
                            <li>‚úì Test with real data</li>
                            <li>‚úì Performance metrics</li>
                        </ul>
                    </div>
                );
        }
    }

    private async handleModeChange(mode: UTLXMode): Promise<void> {
        if (mode === this.state.currentMode) {
            return;
        }

        try {
            const config: ModeConfiguration = {
                mode,
                autoInferSchema: this.state.autoInferSchema,
                enableTypeChecking: this.state.enableTypeChecking
            };

            await this.utlxService.setMode(config);

            this.setState({ currentMode: mode });

            // Notify callbacks
            this.notifyModeChange(mode);

            this.messageService.info(`Switched to ${mode === UTLXMode.DESIGN_TIME ? 'Design-Time' : 'Runtime'} mode`);
        } catch (error) {
            this.messageService.error(`Failed to change mode: ${error}`);
        }
    }

    private async handleAutoInferSchemaChange(enabled: boolean): Promise<void> {
        try {
            const config: ModeConfiguration = {
                mode: this.state.currentMode,
                autoInferSchema: enabled,
                enableTypeChecking: this.state.enableTypeChecking
            };

            await this.utlxService.setMode(config);
            this.setState({ autoInferSchema: enabled });
        } catch (error) {
            this.messageService.error(`Failed to update configuration: ${error}`);
        }
    }

    private async handleTypeCheckingChange(enabled: boolean): Promise<void> {
        try {
            const config: ModeConfiguration = {
                mode: this.state.currentMode,
                autoInferSchema: this.state.autoInferSchema,
                enableTypeChecking: enabled
            };

            await this.utlxService.setMode(config);
            this.setState({ enableTypeChecking: enabled });
        } catch (error) {
            this.messageService.error(`Failed to update configuration: ${error}`);
        }
    }

    private setState(partial: Partial<ModeSelectorState>): void {
        this.state = { ...this.state, ...partial };
        this.update();
    }

    /**
     * Register callback for mode changes
     */
    onModeChange(callback: (mode: UTLXMode) => void): void {
        this.modeChangeCallbacks.push(callback);
    }

    /**
     * Notify all registered callbacks of mode change
     */
    private notifyModeChange(mode: UTLXMode): void {
        this.modeChangeCallbacks.forEach(callback => {
            try {
                callback(mode);
            } catch (error) {
                console.error('Error in mode change callback:', error);
            }
        });
    }

    /**
     * Get current mode
     */
    getCurrentMode(): UTLXMode {
        return this.state.currentMode;
    }

    /**
     * Set mode programmatically
     */
    async setMode(mode: UTLXMode): Promise<void> {
        await this.handleModeChange(mode);
    }
}
