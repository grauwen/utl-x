/**
 * Output Panel Widget
 *
 * Right panel for displaying:
 * - Runtime Mode: Transformation output (XML, JSON, CSV, YAML)
 * - Design-Time Mode: Inferred output schema (JSON Schema)
 */

import * as React from 'react';
import { injectable, inject, postConstruct } from 'inversify';
import { ReactWidget } from '@theia/core/lib/browser/widgets/react-widget';
import { MessageService } from '@theia/core';
import {
    UTLXService, UTLX_SERVICE_SYMBOL,
    UTLXMode,
    ExecutionResult,
    SchemaInferenceResult,
    Diagnostic,
    OUTPUT_PANEL_ID
} from '../../common/protocol';

export interface OutputPanelState {
    mode: UTLXMode;
    content: string;
    format?: string;
    executionTime?: number;
    error?: string;
    diagnostics?: Diagnostic[];
    viewMode: 'pretty' | 'raw';
}

@injectable()
export class OutputPanelWidget extends ReactWidget {
    static readonly ID = OUTPUT_PANEL_ID;
    static readonly LABEL = 'Output';

    @inject(UTLX_SERVICE_SYMBOL)
    protected readonly utlxService!: UTLXService;

    @inject(MessageService)
    protected readonly messageService!: MessageService;

    private state: OutputPanelState = {
        mode: UTLXMode.RUNTIME,
        content: '',
        viewMode: 'pretty'
    };

    constructor() {
        super();
        this.id = OutputPanelWidget.ID;
        this.title.label = OutputPanelWidget.LABEL;
        this.title.caption = 'Output Data/Schema';
        this.title.closable = false;
        this.addClass('utlx-output-panel');
    }

    @postConstruct()
    protected init(): void {
        this.update();
        // Subscribe to mode changes
        this.utlxService.getMode().then(config => {
            this.setState({ mode: config.mode });
        });
    }

    protected onActivateRequest(msg: Message): void {
        super.onActivateRequest(msg);
        this.update();
    }

    protected render(): React.ReactNode {
        const { mode, content, format, executionTime, error, diagnostics, viewMode } = this.state;

        return (
            <div className='utlx-output-panel-container'>
                <div className='utlx-panel-header'>
                    <h3>{mode === UTLXMode.DESIGN_TIME ? 'Output Schema' : 'Output Data'}</h3>
                    <div className='utlx-panel-actions'>
                        <button
                            onClick={() => this.handleCopy()}
                            disabled={!content}
                            title='Copy to clipboard'
                        >
                            üìã Copy
                        </button>
                        <button
                            onClick={() => this.handleSave()}
                            disabled={!content}
                            title='Save to file'
                        >
                            üíæ Save
                        </button>
                        <button
                            onClick={() => this.handleClear()}
                            disabled={!content && !error}
                            title='Clear output'
                        >
                            üóëÔ∏è Clear
                        </button>
                    </div>
                </div>

                <div className='utlx-panel-toolbar'>
                    <label>
                        View:
                        <select
                            value={viewMode}
                            onChange={(e) => this.handleViewModeChange(e.target.value as 'pretty' | 'raw')}
                        >
                            <option value='pretty'>Pretty</option>
                            <option value='raw'>Raw</option>
                        </select>
                    </label>

                    {format && (
                        <span className='utlx-format-badge'>
                            {format.toUpperCase()}
                        </span>
                    )}

                    {executionTime !== undefined && (
                        <span className='utlx-execution-time'>
                            ‚è±Ô∏è {executionTime}ms
                        </span>
                    )}
                </div>

                <div className='utlx-panel-content'>
                    {error ? (
                        <div className='utlx-error-display'>
                            <div className='utlx-error-header'>‚ùå Error</div>
                            <pre className='utlx-error-message'>{error}</pre>
                        </div>
                    ) : content ? (
                        <pre className='utlx-output-display'>
                            {viewMode === 'pretty' ? this.formatContent(content, format) : content}
                        </pre>
                    ) : (
                        <div className='utlx-placeholder'>
                            {mode === UTLXMode.DESIGN_TIME
                                ? 'üí° Click "Infer Schema" to generate output schema'
                                : '‚ñ∂Ô∏è Click "Execute" to see transformation output'}
                        </div>
                    )}

                    {diagnostics && diagnostics.length > 0 && (
                        <div className='utlx-diagnostics'>
                            <div className='utlx-diagnostics-header'>
                                ‚ö†Ô∏è Diagnostics ({diagnostics.length})
                            </div>
                            <ul className='utlx-diagnostics-list'>
                                {diagnostics.map((diagnostic, index) => (
                                    <li key={index} className={`diagnostic-${diagnostic.severity}`}>
                                        <span className='diagnostic-location'>
                                            Line {diagnostic.range.start.line + 1}, Col {diagnostic.range.start.column + 1}:
                                        </span>
                                        <span className='diagnostic-message'>{diagnostic.message}</span>
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}
                </div>

                <div className='utlx-panel-footer'>
                    <span className='utlx-status'>
                        {content
                            ? `${content.length} characters`
                            : error
                            ? 'Error occurred'
                            : 'No output'}
                    </span>
                </div>
            </div>
        );
    }

    private formatContent(content: string, format?: string): string {
        if (!format) {
            return content;
        }

        try {
            switch (format.toLowerCase()) {
                case 'json':
                case 'json-schema':
                    return JSON.stringify(JSON.parse(content), null, 2);
                case 'xml':
                case 'xsd':
                    // Basic XML formatting (just add newlines)
                    return content
                        .replace(/></g, '>\n<')
                        .split('\n')
                        .map((line, index) => {
                            const indent = '  '.repeat(Math.max(0, (line.match(/</g) || []).length - (line.match(/\//g) || []).length));
                            return indent + line.trim();
                        })
                        .join('\n');
                default:
                    return content;
            }
        } catch {
            // If formatting fails, return original content
            return content;
        }
    }

    private async handleCopy(): Promise<void> {
        try {
            await navigator.clipboard.writeText(this.state.content);
            this.messageService.info('Output copied to clipboard');
        } catch (error) {
            this.messageService.error(`Failed to copy: ${error}`);
        }
    }

    private async handleSave(): Promise<void> {
        // TODO: Implement save to file dialog
        this.messageService.info('Save functionality not yet implemented');
    }

    private handleClear(): void {
        this.setState({
            content: '',
            format: undefined,
            executionTime: undefined,
            error: undefined,
            diagnostics: undefined
        });
    }

    private handleViewModeChange(viewMode: 'pretty' | 'raw'): void {
        this.setState({ viewMode });
    }

    private setState(partial: Partial<OutputPanelState>): void {
        this.state = { ...this.state, ...partial };
        this.update();
    }

    /**
     * Display execution result (runtime mode)
     */
    displayExecutionResult(result: ExecutionResult): void {
        if (result.success && result.output) {
            this.setState({
                content: result.output,
                format: result.format,
                executionTime: result.executionTimeMs,
                error: undefined,
                diagnostics: result.diagnostics
            });
        } else {
            this.setState({
                content: '',
                error: result.error || 'Unknown error occurred',
                diagnostics: result.diagnostics,
                executionTime: result.executionTimeMs
            });
        }
    }

    /**
     * Display schema inference result (design-time mode)
     */
    displaySchemaResult(result: SchemaInferenceResult): void {
        if (result.success && result.schema) {
            this.setState({
                content: result.schema,
                format: result.schemaFormat,
                error: undefined,
                diagnostics: result.typeErrors
            });
        } else {
            this.setState({
                content: '',
                error: 'Failed to infer schema',
                diagnostics: result.typeErrors
            });
        }
    }

    /**
     * Display error message
     */
    displayError(error: string): void {
        this.setState({
            content: '',
            error,
            diagnostics: undefined
        });
    }

    /**
     * Set mode from external source
     */
    setMode(mode: UTLXMode): void {
        if (mode !== this.state.mode) {
            this.setState({
                mode,
                content: '',
                error: undefined,
                diagnostics: undefined
            });
        }
    }

    /**
     * Clear all output
     */
    clear(): void {
        this.handleClear();
    }
}
