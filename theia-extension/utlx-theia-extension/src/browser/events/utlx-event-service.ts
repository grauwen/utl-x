/**
 * UTL-X Event Service
 *
 * Centralized event management using Theia's Emitter/Event pattern.
 * Provides type-safe event communication between widgets.
 *
 * Usage:
 * - Publishers: Inject this service and call fire*() methods
 * - Subscribers: Inject this service and subscribe to on*() events
 */

import { injectable } from '@theia/core/shared/inversify';
import { Emitter, Event } from '@theia/core';
import { UTLXMode } from '../../common/protocol';
import { SchemaFieldInfo } from '../utils/schema-field-tree-parser';

/**
 * Event fired when the mode changes between Design-Time and Runtime
 */
export interface ModeChangedEvent {
    mode: UTLXMode;
}

/**
 * Event fired when an input format changes
 */
export interface InputFormatChangedEvent {
    format: string;
    inputId: string;
    isSchema: boolean;
    // CSV-specific parameters
    csvHeaders?: boolean;
    csvDelimiter?: string;
}

/**
 * Event fired when an input name changes
 */
export interface InputNameChangedEvent {
    inputId: string;
    oldName: string;
    newName: string;
}

/**
 * Event fired when a new input is added
 */
export interface InputAddedEvent {
    inputId: string;
    name: string;
}

/**
 * Event fired when an input is deleted
 */
export interface InputDeletedEvent {
    inputId: string;
    name: string;
}

/**
 * Event fired when schema inference is requested for an input
 */
export interface InputInferSchemaEvent {
    inputId: string;
    instanceContent: string;
    instanceFormat: string;
}

/**
 * Event fired when input instance content changes
 */
export interface InputInstanceContentChangedEvent {
    inputId: string;
    content: string;
}

/**
 * Event fired when input schema content changes
 */
export interface InputSchemaContentChangedEvent {
    inputId: string;
    content: string;
}

/**
 * Event fired when an input's UDM representation is updated
 */
export interface InputUdmUpdatedEvent {
    inputId: string;
    inputName: string;
    udmLanguage: string;
    format: string; // json, csv, xml, yaml, etc.
}

/**
 * Event fired when a schema is parsed into a field tree (Design-Time mode)
 * This provides schema-aware field information without needing instance data.
 */
export interface InputSchemaFieldTreeEvent {
    inputId: string;
    inputName: string;
    fieldTree: SchemaFieldInfo[];
    schemaFormat: 'jsch' | 'xsd' | 'osch';
}

/**
 * Event fired when the output format changes
 */
export interface OutputFormatChangedEvent {
    format: string;
    tab: 'instance' | 'schema';
    // CSV-specific options
    csvHeaders?: boolean;
    csvDelimiter?: string;
    csvBom?: boolean;
    // XML-specific options
    xmlEncoding?: string;
    // OData-specific options
    odataMetadata?: 'minimal' | 'full' | 'none';
    odataContext?: string;
    odataWrapCollection?: boolean;
}

/**
 * Event fired when output preset mode is enabled
 * Allows user to provide a target output schema in Design mode
 */
export interface OutputPresetOnEvent {
    schemaContent: string;
    schemaFormat: string;
}

/**
 * Event fired when output preset mode is disabled
 * Returns to normal output display mode
 */
export interface OutputPresetOffEvent {
    // No additional data needed
}

/**
 * Event fired when output schema format changes in preset mode
 */
export interface OutputSchemaFormatChangedEvent {
    format: string;
}

/**
 * Event fired when output schema content changes in preset mode
 */
export interface OutputSchemaContentChangedEvent {
    content: string;
}

/**
 * Event fired when user requests output schema inference (design-time mode)
 */
export interface RequestOutputSchemaInferenceEvent {
    schemaFormat: string;  // 'jsch' | 'xsd'
}

/**
 * Event fired when user requests to load output schema from file (design-time mode)
 */
export interface RequestLoadOutputSchemaEvent {
    schemaFormat: string;  // 'jsch' | 'xsd'
}

/**
 * Event fired when editor content changes
 */
export interface ContentChangedEvent {
    content: string;
}

/**
 * Event fired when UTLX headers are parsed from editor content
 * Used to sync panels with pasted/loaded UTLX files
 */
export interface HeadersParsedEvent {
    inputs: Array<{
        name: string;
        format: string;
        csvHeaders?: boolean;
        csvDelimiter?: string;
        xmlArrays?: string[];
    }>;
    output: {
        format: string;
        csvHeaders?: boolean;
        csvDelimiter?: string;
        csvBom?: boolean;
        xmlEncoding?: string;
    };
}

/**
 * Event fired when UTL-X code is generated by AI
 */
export interface UTLXGeneratedEvent {
    prompt: string;
    utlx?: string;
}

/**
 * Event fired when Execute/Evaluate button is clicked
 */
export interface ExecuteTransformationEvent {
    mode: 'execute' | 'evaluate';
}

/**
 * Event fired when Scaffold Output button is clicked
 */
export interface ScaffoldOutputEvent {
    // No additional data needed - output structure comes from output panel
}

/**
 * Centralized event service for UTL-X widget communication.
 *
 * This service uses Theia's Emitter/Event pattern to provide
 * type-safe, decoupled communication between widgets.
 */
@injectable()
export class UTLXEventService {

    // ===== Mode Change Events =====

    private readonly onModeChangedEmitter = new Emitter<ModeChangedEvent>();
    /**
     * Event fired when the mode changes (Design-Time ‚Üî Runtime)
     */
    readonly onModeChanged: Event<ModeChangedEvent> = this.onModeChangedEmitter.event;

    /**
     * Fire a mode changed event
     */
    fireModeChanged(event: ModeChangedEvent): void {
        console.log('[UTLXEventService] Mode changed:', event.mode);
        this.onModeChangedEmitter.fire(event);
    }

    // ===== Input Management Events =====

    private readonly onInputFormatChangedEmitter = new Emitter<InputFormatChangedEvent>();
    /**
     * Event fired when an input format changes
     */
    readonly onInputFormatChanged: Event<InputFormatChangedEvent> = this.onInputFormatChangedEmitter.event;

    /**
     * Fire an input format changed event
     */
    fireInputFormatChanged(event: InputFormatChangedEvent): void {
        console.log('[UTLXEventService] Input format changed:', event);
        this.onInputFormatChangedEmitter.fire(event);
    }

    private readonly onInputNameChangedEmitter = new Emitter<InputNameChangedEvent>();
    /**
     * Event fired when an input name changes
     */
    readonly onInputNameChanged: Event<InputNameChangedEvent> = this.onInputNameChangedEmitter.event;

    /**
     * Fire an input name changed event
     */
    fireInputNameChanged(event: InputNameChangedEvent): void {
        console.log('[UTLXEventService] Input name changed:', event);
        this.onInputNameChangedEmitter.fire(event);
    }

    private readonly onInputAddedEmitter = new Emitter<InputAddedEvent>();
    /**
     * Event fired when a new input is added
     */
    readonly onInputAdded: Event<InputAddedEvent> = this.onInputAddedEmitter.event;

    /**
     * Fire an input added event
     */
    fireInputAdded(event: InputAddedEvent): void {
        console.log('[UTLXEventService] Input added:', event);
        this.onInputAddedEmitter.fire(event);
    }

    private readonly onInputDeletedEmitter = new Emitter<InputDeletedEvent>();
    /**
     * Event fired when an input is deleted
     */
    readonly onInputDeleted: Event<InputDeletedEvent> = this.onInputDeletedEmitter.event;

    /**
     * Fire an input deleted event
     */
    fireInputDeleted(event: InputDeletedEvent): void {
        console.log('[UTLXEventService] Input deleted:', event);
        this.onInputDeletedEmitter.fire(event);
    }

    private readonly onInputInferSchemaEmitter = new Emitter<InputInferSchemaEvent>();
    /**
     * Event fired when schema inference is requested for an input
     */
    readonly onInputInferSchema: Event<InputInferSchemaEvent> = this.onInputInferSchemaEmitter.event;

    /**
     * Fire an input infer schema event
     */
    fireInputInferSchema(event: InputInferSchemaEvent): void {
        console.log('[UTLXEventService] Input infer schema:', event);
        this.onInputInferSchemaEmitter.fire(event);
    }

    private readonly onInputUdmUpdatedEmitter = new Emitter<InputUdmUpdatedEvent>();
    /**
     * Event fired when an input's UDM representation is updated
     */
    readonly onInputUdmUpdated: Event<InputUdmUpdatedEvent> = this.onInputUdmUpdatedEmitter.event;

    /**
     * Fire an input UDM updated event
     */
    fireInputUdmUpdated(event: InputUdmUpdatedEvent): void {
        console.log('‚ïî' + '‚ïê'.repeat(78) + '‚ïó');
        console.log('‚ïë [UTLXEventService] üî• FIRING Input UDM Updated Event');
        console.log('‚ï†' + '‚ïê'.repeat(78) + '‚ï£');
        console.log('[UTLXEventService] Input ID:', event.inputId);
        console.log('[UTLXEventService] Input Name:', event.inputName);
        console.log('[UTLXEventService] Format:', event.format);
        console.log('[UTLXEventService] UDM Language Length:', event.udmLanguage.length, 'characters');
        console.log('[UTLXEventService] UDM preview (first 500 chars):');
        console.log(event.udmLanguage.substring(0, 500));
        console.log('[UTLXEventService] UDM preview (last 200 chars):');
        console.log(event.udmLanguage.substring(Math.max(0, event.udmLanguage.length - 200)));
        console.log('‚ïö' + '‚ïê'.repeat(78) + '‚ïù');
        this.onInputUdmUpdatedEmitter.fire(event);
    }

    private readonly onInputSchemaFieldTreeEmitter = new Emitter<InputSchemaFieldTreeEvent>();
    /**
     * Event fired when a schema is parsed into a field tree (Design-Time mode)
     */
    readonly onInputSchemaFieldTree: Event<InputSchemaFieldTreeEvent> = this.onInputSchemaFieldTreeEmitter.event;

    /**
     * Fire an input schema field tree event
     */
    fireInputSchemaFieldTree(event: InputSchemaFieldTreeEvent): void {
        console.log('‚ïî' + '‚ïê'.repeat(78) + '‚ïó');
        console.log('‚ïë [UTLXEventService] üî• FIRING Input Schema Field Tree Event');
        console.log('‚ï†' + '‚ïê'.repeat(78) + '‚ï£');
        console.log('[UTLXEventService] Input ID:', event.inputId);
        console.log('[UTLXEventService] Input Name:', event.inputName);
        console.log('[UTLXEventService] Schema Format:', event.schemaFormat);
        console.log('[UTLXEventService] Field Tree Size:', event.fieldTree.length, 'top-level fields');
        console.log('‚ïö' + '‚ïê'.repeat(78) + '‚ïù');
        this.onInputSchemaFieldTreeEmitter.fire(event);
    }

    private readonly onRequestCurrentUdmEmitter = new Emitter<void>();
    /**
     * Event fired when requesting current UDM from all inputs
     * (e.g., when Function Builder opens)
     */
    readonly onRequestCurrentUdm: Event<void> = this.onRequestCurrentUdmEmitter.event;

    /**
     * Fire a request current UDM event
     */
    fireRequestCurrentUdm(): void {
        console.log('[UTLXEventService] Request current UDM from all inputs');
        this.onRequestCurrentUdmEmitter.fire();
    }

    private readonly onInputInstanceContentChangedEmitter = new Emitter<InputInstanceContentChangedEvent>();
    /**
     * Event fired when input instance content changes
     */
    readonly onInputInstanceContentChanged: Event<InputInstanceContentChangedEvent> = this.onInputInstanceContentChangedEmitter.event;

    /**
     * Fire an input instance content changed event
     */
    fireInputInstanceContentChanged(event: InputInstanceContentChangedEvent): void {
        console.log('[UTLXEventService] Input instance content changed:', { inputId: event.inputId, length: event.content.length });
        this.onInputInstanceContentChangedEmitter.fire(event);
    }

    private readonly onInputSchemaContentChangedEmitter = new Emitter<InputSchemaContentChangedEvent>();
    /**
     * Event fired when input schema content changes
     */
    readonly onInputSchemaContentChanged: Event<InputSchemaContentChangedEvent> = this.onInputSchemaContentChangedEmitter.event;

    /**
     * Fire an input schema content changed event
     */
    fireInputSchemaContentChanged(event: InputSchemaContentChangedEvent): void {
        console.log('[UTLXEventService] Input schema content changed:', { inputId: event.inputId, length: event.content.length });
        this.onInputSchemaContentChangedEmitter.fire(event);
    }

    // ===== Output Format Events =====

    private readonly onOutputFormatChangedEmitter = new Emitter<OutputFormatChangedEvent>();
    /**
     * Event fired when the output format changes
     */
    readonly onOutputFormatChanged: Event<OutputFormatChangedEvent> = this.onOutputFormatChangedEmitter.event;

    /**
     * Fire an output format changed event
     */
    fireOutputFormatChanged(event: OutputFormatChangedEvent): void {
        console.log('[UTLXEventService] Output format changed:', event);
        this.onOutputFormatChangedEmitter.fire(event);
    }

    // ===== Output Preset Mode Events =====

    private readonly onOutputPresetOnEmitter = new Emitter<OutputPresetOnEvent>();
    /**
     * Event fired when output preset mode is enabled
     */
    readonly onOutputPresetOn: Event<OutputPresetOnEvent> = this.onOutputPresetOnEmitter.event;

    /**
     * Fire an output preset on event
     */
    fireOutputPresetOn(event: OutputPresetOnEvent): void {
        console.log('[UTLXEventService] Output preset mode enabled:', { format: event.schemaFormat, contentLength: event.schemaContent.length });
        this.onOutputPresetOnEmitter.fire(event);
    }

    private readonly onOutputPresetOffEmitter = new Emitter<OutputPresetOffEvent>();
    /**
     * Event fired when output preset mode is disabled
     */
    readonly onOutputPresetOff: Event<OutputPresetOffEvent> = this.onOutputPresetOffEmitter.event;

    /**
     * Fire an output preset off event
     */
    fireOutputPresetOff(event: OutputPresetOffEvent): void {
        console.log('[UTLXEventService] Output preset mode disabled');
        this.onOutputPresetOffEmitter.fire(event);
    }

    private readonly onOutputSchemaFormatChangedEmitter = new Emitter<OutputSchemaFormatChangedEvent>();
    /**
     * Event fired when output schema format changes in preset mode
     */
    readonly onOutputSchemaFormatChanged: Event<OutputSchemaFormatChangedEvent> = this.onOutputSchemaFormatChangedEmitter.event;

    /**
     * Fire an output schema format changed event
     */
    fireOutputSchemaFormatChanged(event: OutputSchemaFormatChangedEvent): void {
        console.log('[UTLXEventService] Output schema format changed:', event.format);
        this.onOutputSchemaFormatChangedEmitter.fire(event);
    }

    private readonly onOutputSchemaContentChangedEmitter = new Emitter<OutputSchemaContentChangedEvent>();
    /**
     * Event fired when output schema content changes in preset mode
     */
    readonly onOutputSchemaContentChanged: Event<OutputSchemaContentChangedEvent> = this.onOutputSchemaContentChangedEmitter.event;

    /**
     * Fire an output schema content changed event
     */
    fireOutputSchemaContentChanged(event: OutputSchemaContentChangedEvent): void {
        console.log('[UTLXEventService] Output schema content changed:', { length: event.content.length });
        this.onOutputSchemaContentChangedEmitter.fire(event);
    }

    private readonly onRequestOutputSchemaInferenceEmitter = new Emitter<RequestOutputSchemaInferenceEvent>();
    /**
     * Event fired when user requests output schema inference
     */
    readonly onRequestOutputSchemaInference: Event<RequestOutputSchemaInferenceEvent> = this.onRequestOutputSchemaInferenceEmitter.event;

    /**
     * Fire a request output schema inference event
     */
    fireRequestOutputSchemaInference(event: RequestOutputSchemaInferenceEvent): void {
        console.log('[UTLXEventService] Request output schema inference:', event.schemaFormat);
        this.onRequestOutputSchemaInferenceEmitter.fire(event);
    }

    private readonly onRequestLoadOutputSchemaEmitter = new Emitter<RequestLoadOutputSchemaEvent>();
    /**
     * Event fired when user requests to load output schema from file
     */
    readonly onRequestLoadOutputSchema: Event<RequestLoadOutputSchemaEvent> = this.onRequestLoadOutputSchemaEmitter.event;

    /**
     * Fire a request load output schema event
     */
    fireRequestLoadOutputSchema(event: RequestLoadOutputSchemaEvent): void {
        console.log('[UTLXEventService] Request load output schema:', event.schemaFormat);
        this.onRequestLoadOutputSchemaEmitter.fire(event);
    }

    // ===== Content Change Events =====

    private readonly onContentChangedEmitter = new Emitter<ContentChangedEvent>();
    /**
     * Event fired when editor content changes
     */
    readonly onContentChanged: Event<ContentChangedEvent> = this.onContentChangedEmitter.event;

    /**
     * Fire a content changed event
     */
    fireContentChanged(event: ContentChangedEvent): void {
        console.log('[UTLXEventService] Content changed (length:', event.content.length, ')');
        this.onContentChangedEmitter.fire(event);
    }

    private readonly onHeadersParsedEmitter = new Emitter<HeadersParsedEvent>();
    /**
     * Event fired when UTLX headers are parsed from editor content
     */
    readonly onHeadersParsed: Event<HeadersParsedEvent> = this.onHeadersParsedEmitter.event;

    /**
     * Fire a headers parsed event
     */
    fireHeadersParsed(event: HeadersParsedEvent): void {
        console.log('[UTLXEventService] Headers parsed:', { inputs: event.inputs.length, outputFormat: event.output.format });
        this.onHeadersParsedEmitter.fire(event);
    }

    // ===== AI Generation Events =====

    private readonly onUTLXGeneratedEmitter = new Emitter<UTLXGeneratedEvent>();
    /**
     * Event fired when UTL-X code is generated by AI
     */
    readonly onUTLXGenerated: Event<UTLXGeneratedEvent> = this.onUTLXGeneratedEmitter.event;

    /**
     * Fire a UTLX generated event
     */
    fireUTLXGenerated(event: UTLXGeneratedEvent): void {
        console.log('[UTLXEventService] UTLX generated from prompt:', event.prompt);
        this.onUTLXGeneratedEmitter.fire(event);
    }

    // ===== Execute/Evaluate Events =====

    private readonly onExecuteTransformationEmitter = new Emitter<ExecuteTransformationEvent>();
    /**
     * Event fired when Execute/Evaluate button is clicked
     */
    readonly onExecuteTransformation: Event<ExecuteTransformationEvent> = this.onExecuteTransformationEmitter.event;

    /**
     * Fire an execute transformation event
     */
    fireExecuteTransformation(event: ExecuteTransformationEvent): void {
        console.log('[UTLXEventService] ========================================');
        console.log('[UTLXEventService] FIRING Execute Transformation Event');
        console.log('[UTLXEventService] Mode:', event.mode);
        console.log('[UTLXEventService] Event object:', event);
        console.log('[UTLXEventService] Emitter:', this.onExecuteTransformationEmitter);
        console.log('[UTLXEventService] ========================================');
        this.onExecuteTransformationEmitter.fire(event);
        console.log('[UTLXEventService] Event fired to all listeners');
    }

    // ===== Scaffold Output Events =====

    private readonly onScaffoldOutputEmitter = new Emitter<ScaffoldOutputEvent>();
    /**
     * Event fired when Scaffold Output button is clicked
     */
    readonly onScaffoldOutput: Event<ScaffoldOutputEvent> = this.onScaffoldOutputEmitter.event;

    /**
     * Fire a scaffold output event
     */
    fireScaffoldOutput(event: ScaffoldOutputEvent): void {
        console.log('[UTLXEventService] FIRING Scaffold Output Event');
        this.onScaffoldOutputEmitter.fire(event);
    }

    // ===== Lifecycle =====

    /**
     * Dispose of all emitters and cleanup resources
     */
    dispose(): void {
        this.onModeChangedEmitter.dispose();
        this.onInputFormatChangedEmitter.dispose();
        this.onInputNameChangedEmitter.dispose();
        this.onInputAddedEmitter.dispose();
        this.onInputDeletedEmitter.dispose();
        this.onInputInferSchemaEmitter.dispose();
        this.onInputInstanceContentChangedEmitter.dispose();
        this.onInputSchemaContentChangedEmitter.dispose();
        this.onInputSchemaFieldTreeEmitter.dispose();
        this.onOutputFormatChangedEmitter.dispose();
        this.onOutputPresetOnEmitter.dispose();
        this.onOutputPresetOffEmitter.dispose();
        this.onOutputSchemaFormatChangedEmitter.dispose();
        this.onOutputSchemaContentChangedEmitter.dispose();
        this.onRequestOutputSchemaInferenceEmitter.dispose();
        this.onRequestLoadOutputSchemaEmitter.dispose();
        this.onContentChangedEmitter.dispose();
        this.onHeadersParsedEmitter.dispose();
        this.onUTLXGeneratedEmitter.dispose();
        this.onExecuteTransformationEmitter.dispose();
        this.onScaffoldOutputEmitter.dispose();
    }
}
