name: "Lambda Functions and Higher-Order Operations"
description: "Comprehensive tests for lambda functions, map, filter, reduce, and functional composition"
category: "intermediate"
tests:
  - name: "Basic map with lambda"
    input:
      json: |
        {
          "numbers": [1, 2, 3, 4, 5]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        doubled: map(@input.numbers, x => x * 2)
      }
    expected:
      json: |
        {
          "doubled": [2, 4, 6, 8, 10]
        }

  - name: "Filter with lambda predicate"
    input:
      json: |
        {
          "numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        evens: filter(@input.numbers, x => x % 2 == 0)
      }
    expected:
      json: |
        {
          "evens": [2, 4, 6, 8, 10]
        }

  - name: "Reduce with lambda accumulator"
    input:
      json: |
        {
          "numbers": [1, 2, 3, 4, 5]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        sum: reduce(@input.numbers, (acc, x) => acc + x, 0)
      }
    expected:
      json: |
        {
          "sum": 15
        }

  - name: "Chained map and filter"
    input:
      json: |
        {
          "items": [
            {"name": "apple", "price": 1.5},
            {"name": "banana", "price": 0.8},
            {"name": "orange", "price": 2.0},
            {"name": "grape", "price": 3.5}
          ]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        expensiveItems: @input.items
          |> filter(item => item.price > 1.0)
          |> map(item => item.name)
      }
    expected:
      json: |
        {
          "expensiveItems": ["apple", "orange", "grape"]
        }

  - name: "Nested lambda with object transformation"
    input:
      json: |
        {
          "users": [
            {"id": 1, "name": "Alice", "age": 30},
            {"id": 2, "name": "Bob", "age": 25},
            {"id": 3, "name": "Charlie", "age": 35}
          ]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        transformed: map(@input.users, user => {
          userId: user.id,
          fullName: upper(user.name),
          isAdult: user.age >= 18
        })
      }
    expected:
      json: |
        {
          "transformed": [
            {"userId": 1, "fullName": "ALICE", "isAdult": true},
            {"userId": 2, "fullName": "BOB", "isAdult": true},
            {"userId": 3, "fullName": "CHARLIE", "isAdult": true}
          ]
        }

  - name: "Complex reduce for grouping"
    input:
      json: |
        {
          "transactions": [
            {"category": "food", "amount": 50},
            {"category": "transport", "amount": 30},
            {"category": "food", "amount": 75},
            {"category": "entertainment", "amount": 100},
            {"category": "transport", "amount": 25}
          ]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        categoryTotals: reduce(@input.transactions,
          (acc, tx) => {
            let current = acc[tx.category] || 0,
            merge(acc, {[tx.category]: current + tx.amount})
          },
          {}
        )
      }
    expected:
      json: |
        {
          "categoryTotals": {
            "food": 125,
            "transport": 55,
            "entertainment": 100
          }
        }

  - name: "Lambda with conditional logic"
    input:
      json: |
        {
          "scores": [45, 78, 92, 63, 88, 55]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        grades: map(@input.scores, score =>
          if (score >= 90) "A"
          else if (score >= 80) "B"
          else if (score >= 70) "C"
          else if (score >= 60) "D"
          else "F"
        )
      }
    expected:
      json: |
        {
          "grades": ["F", "C", "A", "D", "B", "F"]
        }

  - name: "Filter and reduce combined"
    input:
      json: |
        {
          "products": [
            {"name": "laptop", "price": 1000, "inStock": true},
            {"name": "mouse", "price": 25, "inStock": true},
            {"name": "keyboard", "price": 75, "inStock": false},
            {"name": "monitor", "price": 300, "inStock": true}
          ]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        totalInStock: @input.products
          |> filter(p => p.inStock)
          |> map(p => p.price)
          |> reduce((acc, price) => acc + price, 0)
      }
    expected:
      json: |
        {
          "totalInStock": 1325
        }

  - name: "Lambda with array destructuring"
    input:
      json: |
        {
          "coordinates": [[1, 2], [3, 4], [5, 6]]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        sums: map(@input.coordinates, coord => coord[0] + coord[1])
      }
    expected:
      json: |
        {
          "sums": [3, 7, 11]
        }

  - name: "Map with index access"
    input:
      json: |
        {
          "items": ["apple", "banana", "cherry"]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        indexed: map(@input.items, (item, index) => {
          position: index + 1,
          name: item
        })
      }
    expected:
      json: |
        {
          "indexed": [
            {"position": 1, "name": "apple"},
            {"position": 2, "name": "banana"},
            {"position": 3, "name": "cherry"}
          ]
        }

  - name: "Composition of multiple lambdas"
    input:
      json: |
        {
          "numbers": [1, 2, 3, 4, 5]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        let double = x => x * 2,
        let square = x => x * x,
        let doubleAndSquare = x => square(double(x)),

        result: map(@input.numbers, doubleAndSquare)
      }
    expected:
      json: |
        {
          "result": [4, 16, 36, 64, 100]
        }

  - name: "Filter with complex predicate"
    input:
      json: |
        {
          "employees": [
            {"name": "Alice", "department": "Engineering", "salary": 90000, "experience": 5},
            {"name": "Bob", "department": "Sales", "salary": 70000, "experience": 3},
            {"name": "Charlie", "department": "Engineering", "salary": 120000, "experience": 8},
            {"name": "Diana", "department": "Marketing", "salary": 65000, "experience": 2}
          ]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        seniorEngineers: filter(@input.employees, emp =>
          emp.department == "Engineering" &&
          emp.experience >= 5 &&
          emp.salary > 80000
        )
      }
    expected:
      json: |
        {
          "seniorEngineers": [
            {"name": "Alice", "department": "Engineering", "salary": 90000, "experience": 5},
            {"name": "Charlie", "department": "Engineering", "salary": 120000, "experience": 8}
          ]
        }

  - name: "Reduce to build complex structure"
    input:
      json: |
        {
          "events": [
            {"type": "login", "user": "alice", "timestamp": "2025-01-01T10:00:00Z"},
            {"type": "purchase", "user": "bob", "amount": 50, "timestamp": "2025-01-01T10:05:00Z"},
            {"type": "login", "user": "charlie", "timestamp": "2025-01-01T10:10:00Z"},
            {"type": "purchase", "user": "alice", "amount": 75, "timestamp": "2025-01-01T10:15:00Z"}
          ]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        summary: reduce(@input.events,
          (acc, event) => {
            let loginCount = acc.loginCount + if (event.type == "login") 1 else 0,
            let purchaseTotal = acc.purchaseTotal + (event.amount || 0),
            {
              loginCount: loginCount,
              purchaseTotal: purchaseTotal,
              eventCount: acc.eventCount + 1
            }
          },
          {loginCount: 0, purchaseTotal: 0, eventCount: 0}
        )
      }
    expected:
      json: |
        {
          "summary": {
            "loginCount": 2,
            "purchaseTotal": 125,
            "eventCount": 4
          }
        }

  - name: "Recursive lambda for flattening"
    input:
      json: |
        {
          "nested": [[1, 2], [3, [4, 5]], [6]]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        flat: flatten(@input.nested)
      }
    expected:
      json: |
        {
          "flat": [1, 2, 3, [4, 5], 6]
        }

  - name: "Lambda with string operations"
    input:
      json: |
        {
          "names": ["alice smith", "bob jones", "charlie brown"]
        }
    transformation: |
      %utlx 1.0
      input json
      output json
      ---
      {
        formatted: map(@input.names, name => {
          let words = split(name, " "),
          let capitalized = map(words, word => capitalize(word)),
          join(capitalized, " ")
        })
      }
    expected:
      json: |
        {
          "formatted": ["Alice Smith", "Bob Jones", "Charlie Brown"]
        }
