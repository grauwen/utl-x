TODO's

See https://github.com/grauwen/utl-x/blob/main/docs/architecture/decisions/Next-steps.md
----
Paralellization, see https://github.com/grauwen/utl-x/blob/main/docs/architecture/parallelization-analysis.md
----
Function modules, see https://github.com/grauwen/utl-x/blob/main/docs/architecture/module-system-design.md
----
analysis part

Schema INFERENCE/EXTRACTION: Analyzing XML data to generate a schema that describes it
---
IDE BUG 
After the last change, parse the past in the UTLX, the renaming of the  input is not working correctly anymore, only when there has been a paste of UTLX. When name changed by update of event from UTLX paste action, then the input panel pane name does not update anymore, only when an input is added this change suddenly is triggered

next test name 01-monkey will work

BUG
If one gives the same name to an input as already existed, than both TABS, existing and renamed have the same name and logic is broken


---
 i would suggest not to allow spaces in the
  input names (this should be checked and enforced by the MultipleInputWidget 



----
Improve Parser Error Messages 

  Enhance the parser itself to detect common mistakes and provide better error messages. For example, when parsing object literal properties:

  // If we see IDENTIFIER followed by MINUS, suggest quoting
  if (check(TokenType.IDENTIFIER) && peek(1).type == TokenType.MINUS) {
      error("Property names with hyphens must be quoted. Did you mean \"${current.lexeme}-...\"?")
  }

  This would give: Property names with hyphens must be quoted. Did you mean "order-ide"?


---
API

Multipart/form-data (like file upload)
    - Each input as a separate part with its own encoding
    - Handles binary data natively
    - Standard HTTP, widely supported
    - Better for mixed content types
----
 The correct architecture should be:

  ┌─────────────────────────────────────────┐
  │   Core Transformation Service           │
  │   (parseInput + execute + serializeOutput)│
  └─────────────────────────────────────────┘
                      ▲
                      │
          ┌───────────┴───────────┐
          │                       │
  ┌───────┴────────┐    ┌────────┴─────────┐
  │ CLI Command    │    │  REST API        │
  │ (thin wrapper) │    │  (thin wrapper)  │
  └────────────────┘    └──────────────────┘

First:

  ┌─────────────────────────────────────────┐
  │   Core Transformation Service           │
  │   (parseInput + execute + serializeOutput)│
  └─────────────────────────────────────────┘
                      ▲
                      │
          ┌───────────┴
          │                     
  ┌───────┴────────┐    
  │ CLI Command    │    
  │ (thin wrapper) │    
  └────────────────┘    

Than:

  ┌─────────────────────────────────────────┐
  │   Core Transformation Service           │
  │   (parseInput + execute + serializeOutput)│
  └─────────────────────────────────────────┘
                      ▲
                      │
                      ┴───────────┐
                                  │
                         ┌────────┴─────────┐
                         │  REST API        │
                         │  (thin wrapper)  │
                         └──────────────────┘


IDE integration (LSP for validation)                                                                                                                                                
CI/CD pipelines (fail on errors, warn on lint issues)    

Three options (in order of preference):
  1. Coordination Service ✅ RECOMMENDED - Plain TypeScript class, no widget overhead
  2. Theia Event Bus ✅ GOOD - Type-safe, follows Theia patterns  <== interesting
  3. Window Events ⚠️ CURRENT - Works but not type-safe

Pre-commit hooks                                                                                                                                                                    Build-time validation   
---
Current Tier 1 Hierachical Data: json, csv,xml,yam
Current Tier 2 Hierachical Meta Data: xsd, jsch, avro, proto
Later Tier 3 Hierachical API Contract => EC-API-Design Functional API contract definitions might be a good starting point 
  - OPENAPI - OpenAPI 3.x specs (JSON/YAML with schema embedded)
  - RAML <= advised is not to.
  - RAML fragment <= advise is not to. Use RAML 0.8 and JSON Schema instead.
  - ASYNCAPI <= USDL supports the messaging capabilities.
----
Some conformance-suite input JSCH and XSD examples have no real test output condition
create output format examples for XSD and JSCH
----
Add DEBUGGING cpabilities in the parsers and renders -> Let me remove all the debug statements from the CLI and XSD parser:
----
  - JSON/CSV/XML parsers: Create new parser instance per parse (single-use) <= maybe later fix this?
  - YAML parser: Reusable instance with parse(reader, options) method
  - Options can vary per call, so Yaml instance must be created per-parse with appropriate LoaderOptions
----
JVM Design, init, runtime: 
see https://github.com/grauwen/utl-x/blob/main/docs/architecture/three-phase-runtime-design.md 
see https://github.com/grauwen/utl-x/blob/main/docs/architecture/three-phase-runtime-validation-first.md
  Use Template-Based (first Document):
  - Cloud-native microservices
  - High throughput (>100K msg/s)
  - Validation not critical

  Use Copy-Based Validation-First (second Document):
  - Enterprise middleware (Tibco, IIB, OSB integration)
  - Regulated industries (finance, healthcare)
  - Legacy system integration
  - Security/compliance requirements
----
add functions to abreviate XML tags??? if ther would be an abreviate String function, one could do that manually, but maybe a whole documents needs abreviation?
----
let bindings closure => , COMMA or ; SEMICOLON

All missing lambda functions implemented including conformance-suite tests

----
YAML MAP constructions see https://github.com/grauwen/utl-x/blob/main/stdlib/yaml-maps-json-schema-summary.md

 see the issue! The parser is complaining about comments inside object literals. UTL-X doesn't support # comments inside object literals - comments must be on their own lines. Let me check a
  working test to see the proper syntax:
----
COMMENTS in YAML (snake parser filters them out), Comments (documentation in XML), Need design document
----
/docs/yaml/yaml-dynamic-keys-findings.md

UTL-X has 3 primary patterns for creating dynamic keys in output:                                                                                                                   
1. fromEntries() - Build object from [key, value] pairs array                                                                                                                   
2. mapEntries() - Transform existing object while changing keys/values                                                                                                          
 3. Direct object construction - Compute keys dynamically in literal                                                                                                             
----
DONE Dependency graph construction from AST?
----
DONE The parser needs to allow keywords to be used as property names in object literals
----
The @ symbol is reserved for XML attribute access, not for referencing inputs.??
@ prefix is ONLY for XML attributes, not for input references
   - @input.field → WRONG
    - $input.field → CORRECT
    - element.@attribute → CORRECT
----
Dropdown <list> when an argument is given in an UTLX. (more LSP like capability), sort of API?
----
 The parseCurrency() function has issues with some locale-specific formats (e.g., German Euro parsing), but US format works perfectly. This is a minor edge case that doesn't affect the overall
  excellence of the currency support.
Fixed with seperete currency parsers (swiss, france, eu, us)
----
.gitnore exclude the build jars going into the GIT repo. utlx is a script calling the jar which is not checkin. Keep till a release version?
JAR_PATH="$SCRIPT_DIR/modules/cli/build/libs/cli-1.0.0-SNAPSHOT.jar"
-----
CLI: Documentation: https://utlx-lang.org/docs -> URL is not registered. Change to ....
-----
DONE (dynamic date calculations giving different results). This is a pre-existing test issue ->  boolean comparison bug in the interpreter.
----
utlx transform --input input1=file1.xml --input input2=file2.json script.utlx
----
DONE See https://github.com/grauwen/utl-x/blob/main/docs/architecture/decisions/xsd-discussions-style.md ; the generation of an XSD for the output has to be in a default style and potentially might need configuration to choose the XSD style. 
In the analysis mode there should be more complex logic for nested XSD's and potentially a test for:  --Element Declaration [Local|Global] --Type Declaration [Local|Global]
```
utlx schema -h 
 Output: json-schema (xsd, csv-schema, yaml-schema planned) TODO
```
----
DONE This is a serialization bug in the XML formatter. The array serializer is wrapping each array element in its own parent tag instead of putting all children under a single parent.
----
KEEP Workaround -> DONE
XML 2 JSON cardinality ISSUE
The issue is that when XML has multiple <Module> elements, they might be parsed as an array, but if there's only one, it's a single value. I need to ensure perms.Access.Module is always treated
  as an array. Let me use the ensureArray() function or wrap it:

  The current behavior is actually correct for most cases - it's a well-known XML-to-JSON issue that has no perfect solution. The problem is:

  1. We can't always use arrays - breaks existing code that expects single elements
  2. We can't always use singles - breaks code when cardinality changes

  The real solution is to keep the workaround we added to the test file - check with isArray() before mapping. This is the standard pattern used by all XML-to-JSON converters.

No problem! The XML serializer handles both arrays and single objects correctly, outputting multiple <Module> elements for arrays and single <Module> for single objects.
----
  ### Next Steps for Deployment
       302 +  1. ✅ Conformance testing complete
       303 +  2. Consider performance benchmarking <== TODO
       304 +  3. Consider integration testing with real-world data
       305 +  4. Review security implications
       306 +  5. Prepare release documentation
----

stlib has IO -> how to handle uniform path over unix and windows?
writeFile function does not exist. Maybe needed for dynamic lookups?
Decided no I/O in transform. Lookup can be provided in additional Input
----
DONE  FunctionRegistryGenerator compilation errors

Add stub exportRegistry() method to StandardLibrary/Functions.kt
Implement registry generation from @UTLXFunction annotations
Configure build to bundle registry

Update CLI gradle to include registry in resources
Test that registry loads from JAR
----
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".

  This appears to be a runtime linkage issue between the CLI and stdlib that needs investigation beyond the scope of the current session.

Missing function: daysBetween not implemented in stdlib
The parser doesn't support if expressions with braces { } inside function bodies!

hasKey has two entries (one from the @UTLXFunction annotation in ObjectFunctions.kt, and one as an alias to containsKey). This is a minor duplicate that could be cleaned up later by removing the duplicate implementation.

⏺ Found the parser bug! let...in followed by inline if/else doesn't parse correctly. This is a parser limitation. Since I can't fix the parser easily, let me restructure the functions to avoid this pattern by using nested lets:

The test failure (expected: <IDENTIFIER> but was: <INPUT>) is unrelated to the new token types - it's a pre-existing issue where the test expects "input" to be an identifier, but it's defined as a 
keyword.

xml_namespace_handling test uses wildcard selectors (*[0]) which aren't supported by the current parser. This would require parser enhancements. Let me skip this for now and move to the next failure:

  Parser Limitations (3):
  - xml_namespace_handling - wildcard selectors *[0] not supported
  - yaml_config_processing - complex let bindings with array indexing
  - financial_data_processing - expression evaluation issue

----
CLEANUP-LATER Feedback is enhanced, but also now there is feedback put on private functions (which you don't want probably)
----
CLEANUP-LATER All Functions have duplicated Helper functions. Need some code improvements -> UDMHelper or in another file
----


### Timezone Support
Based on IANA Time Zone Database (tzdata)

### Available Calendars
- `gregory` - Gregorian (default) <= only one supported. The others will make the implementation too big
- `buddhist` - Buddhist calendar
- `chinese` - Chinese calendar
- `hebrew` - Hebrew calendar
- `islamic` - Islamic calendar
- `japanese` - Japanese calendar
Would require external functions. -> leave to Dwafult
----

DONE -TypeOf is both a standard grammar keyword and in the same time a stdlib keyword. -> rename the function typeOf to getType
- formats/plugin/
- stLib
- javascript
- JVM
- tools/vscode-extension/
- tools/maven-plugin/
- tools/intellij-plugin/
- module analysis
- Agentic agent added? How to get an utl for a given inpu and given output
- CLI validate NOT implemented yet

-Parallelization using streams to improve performance

-functions in functions testing to add to conformance suite
- als previous test add to conformance suite as test

Lexer accpets both => and ->     should we add a depricate warning for ->
---
BUGS

The XML serializer expects attributes to be in udm.attributes, but there's no syntax to create attributes from transformations. The @id: value syntax isn't implemented in the parser yet.

tests/examples/basic/json_to_xml_conversion.yaml
These tests use unimplemented syntax features.
——
----
modules/cli/build/libs <-        check if touched by gitore

integrate module analysis (design time) into CLI

log4j alike capabilities?

To unblock the 5 remaining function-related tests, we need to implement let ... in expressions:

  let variable = expression in body

  This is a scoped let binding where the variable is only available within the body expression.

  Would you like me to:
  1. Implement let ... in expressions to fix the remaining 5 tests?
  2. Continue with other grammar gaps (match expressions, try-catch, ternary operator)?
  3. Focus on fixing the other failing tests first?

The cleanest approach is to desugar them to lambda applications during parsing:

  let x = value in body → ((x) => body)(value)

  This automatically creates the proper scoping without AST changes:


REPL
$ utlx repl
  utlx> filter([1,2,3,4,5], x => x % 2 == 0)
  [2, 4]
Future improvements could include:
  - Command history (arrow keys)
  - Tab completion
  - Syntax highlighting
  - Multi-line input
  - Session save/load
  - Auto-save history



TEST for duplicates in the stdlib. e.g. upper

utlx piped working? validate

Byte-Order-Mark (BOM)
First bytes        Encoding assumed
-----------------------------------------
EF BB BF           UTF-8
FE FF              UTF-16 (big-endian)
FF FE              UTF-16 (little-endian)
00 00 FE FF        UTF-32 (big-endian)
FF FE 00 00        UTF-32 (little-endian)
None of the above  UTF-8

<?xml version="1.0" encoding="iso-8859-1" ?>

<?xml version="1.0" encoding="encoding" ?>

DONE -stlib: serialize -> render (DOM -> string) , parse (string -> DOM) :: in theory also binary or string could be used :: distinct parsseJson, parseCsv, parseXml, parseYaml, renderXml, renderYaml, renderCsv, renderJson
DONE -stlib: parseNumber missing
DONE -stlib cannonalize  -> XML Canonicalization (C14N) standards:
-stlib cdata handling in XML?

Test calls these functions that DON'T exist in the ArrayFunction: 
size(), get(). head(), tail(), slice(), flatMap(), sortBy(), distinct(), distinctBy(), union(), intersect(), diff(), isEmpty(), contains(), none()

        register("urlEncode", EncodingFunctions::urlEncode)
        register("urlDecode", EncodingFunctions::urlDecode)
duplication in both EncodingFunctions and URL functions -> make a choise

Xml namespace alias changes, remove namespaces, enforce nullable, empty tags in certain format

pretty print XML and JSON and YAML ??

JSON Web Signatures (JWS) ?

Functions.kt 
1. With method reference (cleaner syntax):
  register("map", ArrayFunctions::map)
2. With lambda wrapper (inline syntax):
  register("singularize") { args -> PluralizationFunctions.singularize(args[0]) }

stlib
JCS (JSON Canonicalization Scheme) - RFC 8785
JWT token handling


This inconsistency suggests that:
  - Some functions were designed to take List<UDM> directly (proper design)
  - Some functions were designed to take individual parameters and need adapters (inconsistent design)


-lerna?

- Comfornmance suite
- Wasm 
- LLVM Bitcode en MILR (two most used IRs for native)?

DONE: Design time generate an output meta data representation like JSON SCHEMA or XSD based on either an XML input example + UTLX def or XSD (or JSON schema) input +UTLX def 
==> - modules/analysis (without yaml support

