TODO's

See https://github.com/grauwen/utl-x/blob/main/docs/architecture/decisions/Next-steps.md
----
Paralellization, see https://github.com/grauwen/utl-x/blob/main/docs/architecture/parallelization-analysis.md
----
Function modules, see https://github.com/grauwen/utl-x/blob/main/docs/architecture/module-system-design.md
----
So the new Theia/VS Code standard would require creating a VS Code extension that wraps the LSP client. This hasn't been implemented yet.
----
So the complete list of UTLX operators is:

  Arithmetic: +, -, *, /, %, **Comparison: ==, !=, <, >, <=, >=Logical: &&, ||, !Special: |> (pipe), ?. (safe navigation), ?? (nullish coalescing), @ (attribute access), => (lambda
  arrow), ... (spread)

---
analysis part

Schema INFERENCE/EXTRACTION: Analyzing XML data to generate a schema that describes it
---
       // Note: XSD namespace option is available in FormatOptions but not yet
       343 +                  // passed to XSDSerializer - may need enhancement in the future
---
 5. Recommendation:

  DON'T add constants - they would:
  - Create two ways to do the same thing (confusing)
  - Be inconsistent with industry standards
  - Add maintenance burden
  - Not provide any functionality that's missing

  DO consider (lower priority):
  - Better documentation of escape sequences
  - IDE support for escape sequence autocomplete
  - Potentially add multi-line string literals (using triple quotes """)
  - Potentially add character code functions (fromCharCode(), charCodeAt()) if requested

----
the existing LSP is designed for UTLX transformation language (.utlx files).

  Answer: No, we don't need a separate LSP server!

  The LSP (Language Server Protocol) is designed to support multiple languages in a single server. The standard approach is to have one LSP server that handles multiple file types by registering different language handlers.

  So for Phase 4, we would:

  1. Extend the existing utlxd LSP to also handle .udm files
  2. Register .udm as a second language alongside .utlx
  3. Add .udm syntax highlighting, validation, etc. as additional capabilities

  Architecture:
  utlxd (LSP Server)
  ├── UTLX Language Handler (.utlx files)
  │   ├── Syntax highlighting
  │   ├── Type checking
  │   ├── Code completion
  │   └── Error diagnostics
  │
  └── UDM Language Handler (.udm files)  ← NEW
      ├── Syntax highlighting
      ├── Parse validation
      ├── Hover info
      └── Error diagnostics

  Implementation approach:
  - Add a new language ID: "udm" (alongside existing "utlx")
  - Register .udm file extension
  - Add UDM-specific syntax rules and validation
  - Share the same LSP server process

  So Phase 4 would be extending the existing utlxd LSP, not creating a second LSP server. This is the standard LSP design pattern used by language servers like typescript-language-server (handles both .ts and .tsx) or
  vscode-json-languageserver (handles JSON and JSON with Comments).


Current implementation:
  - If user edits .utlx file → triggers completion → 500ms processing time
  - During that 500ms, hovering over .udm file → queued, waits

  With parallel handling:
  - .utlx completion → 500ms (Thread 1)
  - .udm hover → 50ms (Thread 2) → returns immediately

  Recommendation:

  For Phase 4, you have two options:

  Option A: Keep current architecture (simpler)
  - .udm and .utlx requests processed sequentially
  - Pro: No changes needed, works today
  - Con: Slower UX if both file types open

  Option B: Add parallel request handling (better UX)
  - Modify SocketTransport to use thread pool
  - Pro: Better performance, responsive UI
  - Con: Need to test thread-safety, ensure writer synchronization
---
I
---
 i would suggest not to allow spaces in the
  input names (this should be checked and enforced by the MultipleInputWidget 



----
Improve Parser Error Messages 

  Enhance the parser itself to detect common mistakes and provide better error messages. For example, when parsing object literal properties:

  // If we see IDENTIFIER followed by MINUS, suggest quoting
  if (check(TokenType.IDENTIFIER) && peek(1).type == TokenType.MINUS) {
      error("Property names with hyphens must be quoted. Did you mean \"${current.lexeme}-...\"?")
  }

  This would give: Property names with hyphens must be quoted. Did you mean "order-ide"?


---
API

Multipart/form-data (like file upload)
    - Each input as a separate part with its own encoding
    - Handles binary data natively
    - Standard HTTP, widely supported
    - Better for mixed content types
----
 The correct architecture should be:

  ┌─────────────────────────────────────────┐
  │   Core Transformation Service           │
  │   (parseInput + execute + serializeOutput)│
  └─────────────────────────────────────────┘
                      ▲
                      │
          ┌───────────┴───────────┐
          │                       │
  ┌───────┴────────┐    ┌────────┴─────────┐
  │ CLI Command    │    │  REST API        │
  │ (thin wrapper) │    │  (thin wrapper)  │
  └────────────────┘    └──────────────────┘

First:

  ┌─────────────────────────────────────────┐
  │   Core Transformation Service           │
  │   (parseInput + execute + serializeOutput)│
  └─────────────────────────────────────────┘
                      ▲
                      │
          ┌───────────┴
          │                     
  ┌───────┴────────┐    
  │ CLI Command    │    
  │ (thin wrapper) │    
  └────────────────┘    

Than:

  ┌─────────────────────────────────────────┐
  │   Core Transformation Service           │
  │   (parseInput + execute + serializeOutput)│
  └─────────────────────────────────────────┘
                      ▲
                      │
                      ┴───────────┐
                                  │
                         ┌────────┴─────────┐
                         │  REST API        │
                         │  (thin wrapper)  │
                         └──────────────────┘


IDE integration (LSP for validation)                                                                                                                                                
CI/CD pipelines (fail on errors, warn on lint issues)    

Three options (in order of preference):
  1. Coordination Service ✅ RECOMMENDED - Plain TypeScript class, no widget overhead
  2. Theia Event Bus ✅ GOOD - Type-safe, follows Theia patterns  <== interesting
  3. Window Events ⚠️ CURRENT - Works but not type-safe

Pre-commit hooks                                                                                                                                                                    Build-time validation   
---
Current Tier 1 Hierachical Data: json, csv,xml,yam
Current Tier 2 Hierachical Meta Data: xsd, jsch, avro, proto
Later Tier 3 Hierachical API Contract => EC-API-Design Functional API contract definitions might be a good starting point 
  - OPENAPI - OpenAPI 3.x specs (JSON/YAML with schema embedded)
  - RAML <= advised is not to.
  - RAML fragment <= advise is not to. Use RAML 0.8 and JSON Schema instead.
  - ASYNCAPI <= USDL supports the messaging capabilities.
----
Some conformance-suite input JSCH and XSD examples have no real test output condition
create output format examples for XSD and JSCH
----
Add DEBUGGING cpabilities in the parsers and renders -> Let me remove all the debug statements from the CLI and XSD parser:
----
  - JSON/CSV/XML parsers: Create new parser instance per parse (single-use) <= maybe later fix this?
  - YAML parser: Reusable instance with parse(reader, options) method
  - Options can vary per call, so Yaml instance must be created per-parse with appropriate LoaderOptions
----
JVM Design, init, runtime: 
see https://github.com/grauwen/utl-x/blob/main/docs/architecture/three-phase-runtime-design.md 
see https://github.com/grauwen/utl-x/blob/main/docs/architecture/three-phase-runtime-validation-first.md
  Use Template-Based (first Document):
  - Cloud-native microservices
  - High throughput (>100K msg/s)
  - Validation not critical

  Use Copy-Based Validation-First (second Document):
  - Enterprise middleware (Tibco, IIB, OSB integration)
  - Regulated industries (finance, healthcare)
  - Legacy system integration
  - Security/compliance requirements
----
add functions to abreviate XML tags??? if ther would be an abreviate String function, one could do that manually, but maybe a whole documents needs abreviation?
----
let bindings closure => , COMMA or ; SEMICOLON

All missing lambda functions implemented including conformance-suite tests

----
YAML MAP constructions see https://github.com/grauwen/utl-x/blob/main/stdlib/yaml-maps-json-schema-summary.md

 see the issue! The parser is complaining about comments inside object literals. UTL-X doesn't support # comments inside object literals - comments must be on their own lines. Let me check a
  working test to see the proper syntax:
----
COMMENTS in YAML (snake parser filters them out), Comments (documentation in XML), Need design document
----
/docs/yaml/yaml-dynamic-keys-findings.md

UTL-X has 3 primary patterns for creating dynamic keys in output:                                                                                                                   
1. fromEntries() - Build object from [key, value] pairs array                                                                                                                   
2. mapEntries() - Transform existing object while changing keys/values                                                                                                          
 3. Direct object construction - Compute keys dynamically in literal                                                                                                             
----
DONE Dependency graph construction from AST?
----
DONE The parser needs to allow keywords to be used as property names in object literals
----
The @ symbol is reserved for XML attribute access, not for referencing inputs.??
@ prefix is ONLY for XML attributes, not for input references
   - @input.field → WRONG
    - $input.field → CORRECT
    - element.@attribute → CORRECT
----
Dropdown <list> when an argument is given in an UTLX. (more LSP like capability), sort of API?
----
 The parseCurrency() function has issues with some locale-specific formats (e.g., German Euro parsing), but US format works perfectly. This is a minor edge case that doesn't affect the overall
  excellence of the currency support.
Fixed with seperete currency parsers (swiss, france, eu, us)
----
.gitnore exclude the build jars going into the GIT repo. utlx is a script calling the jar which is not checkin. Keep till a release version?
JAR_PATH="$SCRIPT_DIR/modules/cli/build/libs/cli-1.0.0-SNAPSHOT.jar"
-----
CLI: Documentation: https://utlx-lang.org/docs -> URL is not registered. Change to ....
-----
DONE (dynamic date calculations giving different results). This is a pre-existing test issue ->  boolean comparison bug in the interpreter.
----
utlx transform --input input1=file1.xml --input input2=file2.json script.utlx
----
DONE See https://github.com/grauwen/utl-x/blob/main/docs/architecture/decisions/xsd-discussions-style.md ; the generation of an XSD for the output has to be in a default style and potentially might need configuration to choose the XSD style. 
In the analysis mode there should be more complex logic for nested XSD's and potentially a test for:  --Element Declaration [Local|Global] --Type Declaration [Local|Global]
```
utlx schema -h 
 Output: json-schema (xsd, csv-schema, yaml-schema planned) TODO
```
----
DONE This is a serialization bug in the XML formatter. The array serializer is wrapping each array element in its own parent tag instead of putting all children under a single parent.
----
KEEP Workaround -> DONE
XML 2 JSON cardinality ISSUE
The issue is that when XML has multiple <Module> elements, they might be parsed as an array, but if there's only one, it's a single value. I need to ensure perms.Access.Module is always treated
  as an array. Let me use the ensureArray() function or wrap it:

  The current behavior is actually correct for most cases - it's a well-known XML-to-JSON issue that has no perfect solution. The problem is:

  1. We can't always use arrays - breaks existing code that expects single elements
  2. We can't always use singles - breaks code when cardinality changes

  The real solution is to keep the workaround we added to the test file - check with isArray() before mapping. This is the standard pattern used by all XML-to-JSON converters.

No problem! The XML serializer handles both arrays and single objects correctly, outputting multiple <Module> elements for arrays and single <Module> for single objects.
----
  ### Next Steps for Deployment
       302 +  1. ✅ Conformance testing complete
       303 +  2. Consider performance benchmarking <== TODO
       304 +  3. Consider integration testing with real-world data
       305 +  4. Review security implications
       306 +  5. Prepare release documentation
----

stlib has IO -> how to handle uniform path over unix and windows?
writeFile function does not exist. Maybe needed for dynamic lookups?
Decided no I/O in transform. Lookup can be provided in additional Input
----
DONE  FunctionRegistryGenerator compilation errors

Add stub exportRegistry() method to StandardLibrary/Functions.kt
Implement registry generation from @UTLXFunction annotations
Configure build to bundle registry

Update CLI gradle to include registry in resources
Test that registry loads from JAR
----
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".

  This appears to be a runtime linkage issue between the CLI and stdlib that needs investigation beyond the scope of the current session.

Missing function: daysBetween not implemented in stdlib
The parser doesn't support if expressions with braces { } inside function bodies!

hasKey has two entries (one from the @UTLXFunction annotation in ObjectFunctions.kt, and one as an alias to containsKey). This is a minor duplicate that could be cleaned up later by removing the duplicate implementation.

⏺ Found the parser bug! let...in followed by inline if/else doesn't parse correctly. This is a parser limitation. Since I can't fix the parser easily, let me restructure the functions to avoid this pattern by using nested lets:

The test failure (expected: <IDENTIFIER> but was: <INPUT>) is unrelated to the new token types - it's a pre-existing issue where the test expects "input" to be an identifier, but it's defined as a 
keyword.

xml_namespace_handling test uses wildcard selectors (*[0]) which aren't supported by the current parser. This would require parser enhancements. Let me skip this for now and move to the next failure:

  Parser Limitations (3):
  - xml_namespace_handling - wildcard selectors *[0] not supported
  - yaml_config_processing - complex let bindings with array indexing
  - financial_data_processing - expression evaluation issue

----
CLEANUP-LATER Feedback is enhanced, but also now there is feedback put on private functions (which you don't want probably)
----
CLEANUP-LATER All Functions have duplicated Helper functions. Need some code improvements -> UDMHelper or in another file
----


### Timezone Support
Based on IANA Time Zone Database (tzdata)

### Available Calendars
- `gregory` - Gregorian (default) <= only one supported. The others will make the implementation too big
- `buddhist` - Buddhist calendar
- `chinese` - Chinese calendar
- `hebrew` - Hebrew calendar
- `islamic` - Islamic calendar
- `japanese` - Japanese calendar
Would require external functions. -> leave to Dwafult
----

DONE -TypeOf is both a standard grammar keyword and in the same time a stdlib keyword. -> rename the function typeOf to getType
- formats/plugin/
- stLib
- javascript
- JVM
- tools/vscode-extension/
- tools/maven-plugin/
- tools/intellij-plugin/
- module analysis
- Agentic agent added? How to get an utl for a given inpu and given output
- CLI validate NOT implemented yet

-Parallelization using streams to improve performance

-functions in functions testing to add to conformance suite
- als previous test add to conformance suite as test

Lexer accpets both => and ->     should we add a depricate warning for ->
---
BUGS

The XML serializer expects attributes to be in udm.attributes, but there's no syntax to create attributes from transformations. The @id: value syntax isn't implemented in the parser yet.

tests/examples/basic/json_to_xml_conversion.yaml
These tests use unimplemented syntax features.
——
----
modules/cli/build/libs <-        check if touched by gitore

integrate module analysis (design time) into CLI

log4j alike capabilities?

To unblock the 5 remaining function-related tests, we need to implement let ... in expressions:

  let variable = expression in body

  This is a scoped let binding where the variable is only available within the body expression.

  Would you like me to:
  1. Implement let ... in expressions to fix the remaining 5 tests?
  2. Continue with other grammar gaps (match expressions, try-catch, ternary operator)?
  3. Focus on fixing the other failing tests first?

The cleanest approach is to desugar them to lambda applications during parsing:

  let x = value in body → ((x) => body)(value)

  This automatically creates the proper scoping without AST changes:


REPL
$ utlx repl
  utlx> filter([1,2,3,4,5], x => x % 2 == 0)
  [2, 4]
Future improvements could include:
  - Command history (arrow keys)
  - Tab completion
  - Syntax highlighting
  - Multi-line input
  - Session save/load
  - Auto-save history



TEST for duplicates in the stdlib. e.g. upper

utlx piped working? validate

Byte-Order-Mark (BOM)
First bytes        Encoding assumed
-----------------------------------------
EF BB BF           UTF-8
FE FF              UTF-16 (big-endian)
FF FE              UTF-16 (little-endian)
00 00 FE FF        UTF-32 (big-endian)
FF FE 00 00        UTF-32 (little-endian)
None of the above  UTF-8

<?xml version="1.0" encoding="iso-8859-1" ?>

<?xml version="1.0" encoding="encoding" ?>

DONE -stlib: serialize -> render (DOM -> string) , parse (string -> DOM) :: in theory also binary or string could be used :: distinct parsseJson, parseCsv, parseXml, parseYaml, renderXml, renderYaml, renderCsv, renderJson
DONE -stlib: parseNumber missing
DONE -stlib cannonalize  -> XML Canonicalization (C14N) standards:
-stlib cdata handling in XML?

Test calls these functions that DON'T exist in the ArrayFunction: 
size(), get(). head(), tail(), slice(), flatMap(), sortBy(), distinct(), distinctBy(), union(), intersect(), diff(), isEmpty(), contains(), none()

        register("urlEncode", EncodingFunctions::urlEncode)
        register("urlDecode", EncodingFunctions::urlDecode)
duplication in both EncodingFunctions and URL functions -> make a choise

Xml namespace alias changes, remove namespaces, enforce nullable, empty tags in certain format

pretty print XML and JSON and YAML ??

JSON Web Signatures (JWS) ?

Functions.kt 
1. With method reference (cleaner syntax):
  register("map", ArrayFunctions::map)
2. With lambda wrapper (inline syntax):
  register("singularize") { args -> PluralizationFunctions.singularize(args[0]) }

stlib
JCS (JSON Canonicalization Scheme) - RFC 8785
JWT token handling


This inconsistency suggests that:
  - Some functions were designed to take List<UDM> directly (proper design)
  - Some functions were designed to take individual parameters and need adapters (inconsistent design)


-lerna?

- Comfornmance suite
- Wasm 
- LLVM Bitcode en MILR (two most used IRs for native)?

DONE: Design time generate an output meta data representation like JSON SCHEMA or XSD based on either an XML input example + UTLX def or XSD (or JSON schema) input +UTLX def 
==> - modules/analysis (without yaml support

