TODO's

See https://github.com/grauwen/utl-x/blob/main/docs/architecture/decisions/Next-steps.md
----
Paralellization, see https://github.com/grauwen/utl-x/blob/main/docs/architecture/parallelization-analysis.md
----
Function modules, see https://github.com/grauwen/utl-x/blob/main/docs/architecture/module-system-design.md
----
hese XSDParserTest failures appear to be pre-existing issues with the parser (not the serializer I 
----
analysis part
e.g. modules/analysis/src/test/kotlin/org/apache/utlx/analysis/validation/TransformValidatorTest.kt
@Disabled("TODO: TypeContext API needs implementation for advanced type inference features")
----
  Likely cause: type may be a reserved keyword or conflicts with the type system. ?
So the parser has a bug where it's rejecting type as a parameter name when it shouldn't. Should I investigate why the parser is rejecting it?
----
IDE integration (LSP for validation)                                                                                                                                                
CI/CD pipelines (fail on errors, warn on lint issues)                                                                                                                               Pre-commit hooks                                                                                                                                                                    Build-time validation   
---
Later
  - OPENAPI - OpenAPI 3.x specs (JSON/YAML with schema embedded)
  - RAML
  - RAML fragment
  - ASYNCAPI
and more. Need to rethink
----
conformance-suite input JSCH and XSD examples have no real test output condition

----
Add DEBUGGING cpabilities in the parsers and renders -> Let me remove all the debug statements from the CLI and XSD parser:
----


Issues:

The test failed as expected - it's trying to access __metadata fields that aren't implemented yet

Now I can see the actual structure. The xs:schema wrapper is NOT being removed <= whould that be done or not?

When there's only ONE xs:complexType, it's an object, not an array. XML-to-JSON conversion only creates arrays when there are multiple elements with the same name.
  Since the test transformation uses map(), it fails when given a single object instead of an array.


----
create output format examples for XSD and JSCH
----
JVM Design, init, runtime: 
see https://github.com/grauwen/utl-x/blob/main/docs/architecture/three-phase-runtime-design.md 
see https://github.com/grauwen/utl-x/blob/main/docs/architecture/three-phase-runtime-validation-first.md
  Use Template-Based (first Document):
  - Cloud-native microservices
  - High throughput (>100K msg/s)
  - Validation not critical

  Use Copy-Based Validation-First (second Document):
  - Enterprise middleware (Tibco, IIB, OSB integration)
  - Regulated industries (finance, healthcare)
  - Legacy system integration
  - Security/compliance requirements
----
add functions to abreviate XML tags??? if ther would be an abreviate String function, one could do that manually, but maybe a whole documents needs abreviation?
----
All missing lambda functions implemented including conformance-suite tests


  2. Fix syntax issues in tests 02-07 (count(), match, entries structure, let bindings)
  3. Achieve 9/9 passing tests for complete DataContract dynamic key support

  1. Fix remaining syntax issues in tests 02-07 (count(), match, entries, let bindings)
  2. Run full conformance suite - target: 9/9 DataContract tests passing
  3. Consider implementing additional higher-order functions (groupBy, indexBy, etc.)
----
YAML MAP constructions see https://github.com/grauwen/utl-x/blob/main/stdlib/yaml-maps-json-schema-summary.md

 1. Verify existing stdlib - Check if keys(), values(), hasKey() already exist
  2. Implement missing functions - Add the essential object manipulation functions
  3. Create comprehensive test suite - DataContract-style YAML with dynamic keys
  4. Document patterns - Best practices for handling dynamic keys in UTL-X
  5. Add examples - Real-world DataContract transformation examples

 see the issue! The parser is complaining about comments inside object literals. UTL-X doesn't support # comments inside object literals - comments must be on their own lines. Let me check a
  working test to see the proper syntax:

COMMENTS in YAML, Comments (documentation in XML), Need design document

docs/yaml-dynamic-keys-findings.md

UTL-X has 3 primary patterns for creating dynamic keys in output:                                                                                                                   
1. fromEntries() - Build object from [key, value] pairs array                                                                                                                   
2. mapEntries() - Transform existing object while changing keys/values                                                                                                          
 3. Direct object construction - Compute keys dynamically in literal                                                                                                             
Plan: Create Comprehensive Documentation 

----
Dependency graph construction from AST?
----
The parser needs to allow keywords to be used as property names in object literals
----
The @ symbol is reserved for XML attribute access, not for referencing inputs.??
@ prefix is ONLY for XML attributes, not for input references
   - @input.field → WRONG
    - input.field → CORRECT
    - element.@attribute → CORRECT
----
Dropdown <list> when an argument is given in an UTLX. (more LSP like capability), sort of API?
----
 The parseCurrency() function has issues with some locale-specific formats (e.g., German Euro parsing), but US format works perfectly. This is a minor edge case that doesn't affect the overall
  excellence of the currency support.
----

.gitnore exclude the build jars going into the GIT repo. utlx is a script calling the jar which is not checkin. Keep till a release version?
JAR_PATH="$SCRIPT_DIR/modules/cli/build/libs/cli-1.0.0-SNAPSHOT.jar"
-----
CLI: Documentation: https://utlx-lang.org/docs -> URL is not registered. Change to ....
-----
(dynamic date calculations giving different results). This is a pre-existing test issue ->  boolean comparison bug in the interpreter.
----
utlx transform --input input1=file1.xml --input input2=file2.json script.utlx
----
See https://github.com/grauwen/utl-x/blob/main/docs/architecture/decisions/xsd-discussions-style.md ; the generation of an XSD for the output has to be in a default style and potentially might need configuration to choose the XSD style. 
In the analysis mode there should be more complex logic for nested XSD's and potentially a test for:  --Element Declaration [Local|Global] --Type Declaration [Local|Global]
```
utlx schema -h 
 Output: json-schema (xsd, csv-schema, yaml-schema planned) TODO
```
----
This is a serialization bug in the XML formatter. The array serializer is wrapping each array element in its own parent tag instead of putting all children under a single parent.
----
KEEP Workaround -> DONE
XML 2 JSON cardinality ISSUE
The issue is that when XML has multiple <Module> elements, they might be parsed as an array, but if there's only one, it's a single value. I need to ensure perms.Access.Module is always treated
  as an array. Let me use the ensureArray() function or wrap it:

  The current behavior is actually correct for most cases - it's a well-known XML-to-JSON issue that has no perfect solution. The problem is:

  1. We can't always use arrays - breaks existing code that expects single elements
  2. We can't always use singles - breaks code when cardinality changes

  The real solution is to keep the workaround we added to the test file - check with isArray() before mapping. This is the standard pattern used by all XML-to-JSON converters.

No problem! The XML serializer handles both arrays and single objects correctly, outputting multiple <Module> elements for arrays and single <Module> for single objects.
----
  ### Next Steps for Deployment
       302 +  1. ✅ Conformance testing complete
       303 +  2. Consider performance benchmarking
       304 +  3. Consider integration testing with real-world data
       305 +  4. Review security implications
       306 +  5. Prepare release documentation
       307 +  
----

stlib has IO -> how to handle uniform path over unix and windows?
writeFile function does not exist. Maybe needed for dynamic lookups?
----
Fix FunctionRegistryGenerator compilation errors

Add stub exportRegistry() method to StandardLibrary/Functions.kt
Implement registry generation from @UTLXFunction annotations
Configure build to bundle registry

Update CLI gradle to include registry in resources
Test that registry loads from JAR
----
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".

  This appears to be a runtime linkage issue between the CLI and stdlib that needs investigation beyond the scope of the current session.

Missing function: daysBetween not implemented in stdlib
The parser doesn't support if expressions with braces { } inside function bodies!

hasKey has two entries (one from the @UTLXFunction annotation in ObjectFunctions.kt, and one as an alias to containsKey). This is a minor duplicate that could be cleaned up later by removing the duplicate implementation.

⏺ Found the parser bug! let...in followed by inline if/else doesn't parse correctly. This is a parser limitation. Since I can't fix the parser easily, let me restructure the functions to avoid this pattern by using nested lets:

The test failure (expected: <IDENTIFIER> but was: <INPUT>) is unrelated to the new token types - it's a pre-existing issue where the test expects "input" to be an identifier, but it's defined as a 
keyword.

xml_namespace_handling test uses wildcard selectors (*[0]) which aren't supported by the current parser. This would require parser enhancements. Let me skip this for now and move to the next failure:

  Parser Limitations (3):
  - xml_namespace_handling - wildcard selectors *[0] not supported
  - yaml_config_processing - complex let bindings with array indexing
  - financial_data_processing - expression evaluation issue

----
CLEANUP-LATER Feedback is enhanced, but also now there is feedback put on private functions (which you don't want probably)
----
CLEANUP-LATER All Functions have duplicated Helper functions. Need some code improvements -> UDMHelper or in another file
----


### Timezone Support
Based on IANA Time Zone Database (tzdata)

### Available Calendars
- `gregory` - Gregorian (default)
- `buddhist` - Buddhist calendar
- `chinese` - Chinese calendar
- `hebrew` - Hebrew calendar
- `islamic` - Islamic calendar
- `japanese` - Japanese calendar
Would require external functions. -> leave to Dwafult
----

DONE -TypeOf is both a standard grammar keyword and in the same time a stdlib keyword. -> rename the function typeOf to getType
- formats/plugin/
- stLib
- javascript
- JVM
- tools/vscode-extension/
- tools/maven-plugin/
- tools/intellij-plugin/
- module analysis
- Agentic agent added? How to get an utl for a given inpu and given output
- CLI validate NOT implemented yet

-Parallelization using streams to improve performance

-functions in functions testing to add to conformance suite
- als previous test add to conformance suite as test

Lexer accpets both => and ->     should we add a depricate warning for ->
---
BUGS

The XML serializer expects attributes to be in udm.attributes, but there's no syntax to create attributes from transformations. The @id: value syntax isn't implemented in the parser yet.

tests/examples/basic/json_to_xml_conversion.yaml
These tests use unimplemented syntax features.
——
----
modules/cli/build/libs <-        check if touched by gitore

integrate module analysis (design time) into CLI

log4j alike capabilities?

To unblock the 5 remaining function-related tests, we need to implement let ... in expressions:

  let variable = expression in body

  This is a scoped let binding where the variable is only available within the body expression.

  Would you like me to:
  1. Implement let ... in expressions to fix the remaining 5 tests?
  2. Continue with other grammar gaps (match expressions, try-catch, ternary operator)?
  3. Focus on fixing the other failing tests first?

The cleanest approach is to desugar them to lambda applications during parsing:

  let x = value in body → ((x) => body)(value)

  This automatically creates the proper scoping without AST changes:


REPL
$ utlx repl
  utlx> filter([1,2,3,4,5], x => x % 2 == 0)
  [2, 4]
Future improvements could include:
  - Command history (arrow keys)
  - Tab completion
  - Syntax highlighting
  - Multi-line input
  - Session save/load
  - Auto-save history



TEST for duplicates in the stdlib. e.g. upper

utlx piped working? validate

Byte-Order-Mark (BOM)
First bytes        Encoding assumed
-----------------------------------------
EF BB BF           UTF-8
FE FF              UTF-16 (big-endian)
FF FE              UTF-16 (little-endian)
00 00 FE FF        UTF-32 (big-endian)
FF FE 00 00        UTF-32 (little-endian)
None of the above  UTF-8

<?xml version="1.0" encoding="iso-8859-1" ?>

<?xml version="1.0" encoding="encoding" ?>

DONE -stlib: serialize -> render (DOM -> string) , parse (string -> DOM) :: in theory also binary or string could be used :: distinct parsseJson, parseCsv, parseXml, parseYaml, renderXml, renderYaml, renderCsv, renderJson
DONE -stlib: parseNumber missing
DONE -stlib cannonalize  -> XML Canonicalization (C14N) standards:
-stlib cdata handling in XML?

Test calls these functions that DON'T exist in the ArrayFunction: 
size(), get(). head(), tail(), slice(), flatMap(), sortBy(), distinct(), distinctBy(), union(), intersect(), diff(), isEmpty(), contains(), none()

        register("urlEncode", EncodingFunctions::urlEncode)
        register("urlDecode", EncodingFunctions::urlDecode)
duplication in both EncodingFunctions and URL functions -> make a choise

Xml namespace alias changes, remove namespaces, enforce nullable, empty tags in certain format

pretty print XML and JSON and YAML ??

JSON Web Signatures (JWS) ?

Functions.kt 
1. With method reference (cleaner syntax):
  register("map", ArrayFunctions::map)
2. With lambda wrapper (inline syntax):
  register("singularize") { args -> PluralizationFunctions.singularize(args[0]) }

stlib
JCS (JSON Canonicalization Scheme) - RFC 8785
JWT token handling


This inconsistency suggests that:
  - Some functions were designed to take List<UDM> directly (proper design)
  - Some functions were designed to take individual parameters and need adapters (inconsistent design)


-lerna?

- Comfornmance suite
- Wasm 
- LLVM Bitcode en MILR (two most used IRs for native)?

DONE: Design time generate an output meta data representation like JSON SCHEMA or XSD based on either an XML input example + UTLX def or XSD (or JSON schema) input +UTLX def 
==> - modules/analysis (without yaml support

