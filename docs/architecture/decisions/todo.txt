TODO's

See https://github.com/grauwen/utl-x/blob/main/docs/architecture/decisions/Next-steps.md

Issue discovered: The CLI binary appears to not be picking up the stdlib functions properly at runtime, even though:
  - parseDate is defined and registered in stdlib
  - Function registry is up to date
  - CLI jar was rebuilt

3.2.5 Functions (User-Defined) <- should not overwrite a standard function I presume. Functionname needs to start with something like a capital? Or F- or else?

See https://github.com/grauwen/utl-x/blob/main/docs/architecture/decisions/xsd-discussions-style.md ; the generation of an XSD for the output has to be in a default style and potentially might need configuration to choose the XSD style
```
utlx schema -h 
 Output: json-schema (xsd, csv-schema, yaml-schema planned) TODO
```
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".

  This appears to be a runtime linkage issue between the CLI and stdlib that needs investigation beyond the scope of the current session.

Missing function: daysBetween not implemented in stdlib
The parser doesn't support if expressions with braces { } inside function bodies!

hasKey has two entries (one from the @UTLXFunction annotation in ObjectFunctions.kt, and one as an alias to containsKey). This is a minor duplicate that could be cleaned up later by removing the duplicate implementation.

⏺ Found the parser bug! let...in followed by inline if/else doesn't parse correctly. This is a parser limitation. Since I can't fix the parser easily, let me restructure the functions to avoid this pattern by using nested lets:

The test failure (expected: <IDENTIFIER> but was: <INPUT>) is unrelated to the new token types - it's a pre-existing issue where the test expects "input" to be an identifier, but it's defined as a 
keyword.

xml_namespace_handling test uses wildcard selectors (*[0]) which aren't supported by the current parser. This would require parser enhancements. Let me skip this for now and move to the next failure:

  Parser Limitations (3):
  - xml_namespace_handling - wildcard selectors *[0] not supported
  - yaml_config_processing - complex let bindings with array indexing
  - financial_data_processing - expression evaluation issue

### Timezone Support
Based on IANA Time Zone Database (tzdata)

### Available Calendars
- `gregory` - Gregorian (default)
- `buddhist` - Buddhist calendar
- `chinese` - Chinese calendar
- `hebrew` - Hebrew calendar
- `islamic` - Islamic calendar
- `japanese` - Japanese calendar

-TypeOf is both a standard grammar keyword and in the same time a stdlib keyword. -> rename the function typeOf to getType
- formats/plugin/
- stLib
- javascript
- JVM
- tools/vscode-extension/
- tools/maven-plugin/
- tools/intellij-plugin/
- module analysis
- Agentic agent added? How to get an utl for a given inpu and given output
- CLI validate NOT implemented yet

-Parallelization using streams to improve performance

-functions in functions testing to add to conformance suite
- als previous test add to conformance suite as test

Lexer accpets both => and ->     should we add a depricate warning for ->
---
BUGS

The XML serializer expects attributes to be in udm.attributes, but there's no syntax to create attributes from transformations. The @id: value syntax isn't implemented in the parser yet.

tests/examples/basic/json_to_xml_conversion.yaml
These tests use unimplemented syntax features.
——
----
modules/cli/build/libs <-        check if touched by gitore

integrate module analysis (design time) into CLI

log4j alike capabilities?

To unblock the 5 remaining function-related tests, we need to implement let ... in expressions:

  let variable = expression in body

  This is a scoped let binding where the variable is only available within the body expression.

  Would you like me to:
  1. Implement let ... in expressions to fix the remaining 5 tests?
  2. Continue with other grammar gaps (match expressions, try-catch, ternary operator)?
  3. Focus on fixing the other failing tests first?

The cleanest approach is to desugar them to lambda applications during parsing:

  let x = value in body → ((x) => body)(value)

  This automatically creates the proper scoping without AST changes:


REPL
$ utlx repl
  utlx> filter([1,2,3,4,5], x => x % 2 == 0)
  [2, 4]
Future improvements could include:
  - Command history (arrow keys)
  - Tab completion
  - Syntax highlighting
  - Multi-line input
  - Session save/load
  - Auto-save history



TEST for duplicates in the stdlib. e.g. upper

utlx piped working? validate

Byte-Order-Mark (BOM)
First bytes        Encoding assumed
-----------------------------------------
EF BB BF           UTF-8
FE FF              UTF-16 (big-endian)
FF FE              UTF-16 (little-endian)
00 00 FE FF        UTF-32 (big-endian)
FF FE 00 00        UTF-32 (little-endian)
None of the above  UTF-8

<?xml version="1.0" encoding="iso-8859-1" ?>

<?xml version="1.0" encoding="encoding" ?>

DONE -stlib: serialize -> render (DOM -> string) , parse (string -> DOM) :: in theory also binary or string could be used :: distinct parsseJson, parseCsv, parseXml, parseYaml, renderXml, renderYaml, renderCsv, renderJson
DONE -stlib: parseNumber missing
DONE -stlib cannonalize  -> XML Canonicalization (C14N) standards:
-stlib cdata handling in XML?

Test calls these functions that DON'T exist in the ArrayFunction: 
size(), get(). head(), tail(), slice(), flatMap(), sortBy(), distinct(), distinctBy(), union(), intersect(), diff(), isEmpty(), contains(), none()

        register("urlEncode", EncodingFunctions::urlEncode)
        register("urlDecode", EncodingFunctions::urlDecode)
duplication in both EncodingFunctions and URL functions -> make a choise

Xml namespace alias changes, remove namespaces, enforce nullable, empty tags in certain format

pretty print XML and JSON and YAML ??

JSON Web Signatures (JWS) ?

Functions.kt 
1. With method reference (cleaner syntax):
  register("map", ArrayFunctions::map)
2. With lambda wrapper (inline syntax):
  register("singularize") { args -> PluralizationFunctions.singularize(args[0]) }

stlib
JCS (JSON Canonicalization Scheme) - RFC 8785
JWT token handling


This inconsistency suggests that:
  - Some functions were designed to take List<UDM> directly (proper design)
  - Some functions were designed to take individual parameters and need adapters (inconsistent design)


-lerna?

- Comfornmance suite
- Wasm 
- LLVM Bitcode en MILR (two most used IRs for native)?

DONE: Design time generate an output meta data representation like JSON SCHEMA or XSD based on either an XML input example + UTLX def or XSD (or JSON schema) input +UTLX def 
==> - modules/analysis (without yaml support)
